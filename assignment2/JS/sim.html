<!DOCTYPE html>
<html>
<head>
    <title>Canvas Template</title>
    <meta charset="utf-8" />
    <title>TNM111 InfoVis Assignment 2</title>
    <meta name="description" content="Particle sim" />
</head>
<body>
    <style>
        body{
            background-color: blueviolet;
            overflow: hidden;
        }
        body, canvas {
            border: 0;
            margin: 0;
            padding: 0;
        }
        #simCanvas{
            background-color: rgb(255, 255, 255);
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        button{
            position:static;
            top: 10px;
            left: 10px;  
        }
    </style>
    <input type="file" id="fileInput" accept=".csv" />
    <button id="dataPointspawn">Spawn Data Points</button>
    <script>
        
        window.addEventListener('DOMContentLoaded', () => {
        // Define constants

        window.onresize = function () { location.reload(); }
        const FPS = 60;
        const h = 10/FPS; 
        let tfCanvas = document.querySelector("#simCanvas");
        var c = tfCanvas.getContext("2d");

        
        // handle canvas size
        var displayWidth = window.innerWidth;
        var displayHeight = window.innerHeight;
        var scale = 2;
        tfCanvas.style.width = displayWidth + 'px';
        tfCanvas.style.height = displayHeight + 'px';
        tfCanvas.width = displayWidth * scale;
        tfCanvas.height = displayHeight * scale;

        // define mouse
        var mouse = { x: 0, y: 0};

        c.lineWidth = 5;
        c.moveTo(10, displayHeight);
        c.lineTo(displayWidth * 2 - 20, displayHeight);
        c.stroke();
        
        c.moveTo(displayWidth, 10);
        c.lineTo(displayWidth, (displayHeight * 2) - 50);
        c.stroke();
        c.lineWidth = .5;

        function getMousePos(canvas, evt) {
            var rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        window.addEventListener('mousemove', function (e) {
            var mousePos = getMousePos(tfCanvas, e);

            mouse.x = mousePos.x * scale;
            mouse.y = mousePos.y * scale;
        }, false);

        window.addEventListener('mousedown', function (e) {
            var mousePos = getMousePos(tfCanvas, e);

            mouse.x = mousePos.x * scale;
            mouse.y = mousePos.y * scale;
            //console.log(mouse);

            if (e.buttons == 1) {
                //dragBallInterval = setInterval(dragBalls, FPS);
            }
        }, false);

        window.addEventListener('mouseup', function (e) {
            if (!(e.buttons == 1)) {
                //clearInterval(dragBallInterval);
            }
        }, false);

        var arrayOfRainbowColors = [
            "ff0000",
            "ffa500",
            "ffff00",
            "008000",
            "0000ff",
            "4b0082",
            "ee82ee"
        ];

        function hexToRgb(hex) {
            var r = parseInt(hex.substring(0, 2), 16);
            var g = parseInt(hex.substring(2, 4), 16);
            var b = parseInt(hex.substring(4, 6), 16);
            return "rgb(" + r + ", " + g + ", " + b + ")";
        }

        function getNextColor() {
            let color = arrayOfRainbowColors.shift();
            arrayOfRainbowColors.push(color);
            return color;
        }

        dataPoints = [];
        class DataPoint {
            constructor(x, y, name, radius, color) {
                this.x = x;
                this.y = y;
                this.name = name;
                this.radius = radius;
                this.color = color;
            }

            draw = function () {
                c.beginPath();
                switch (this.name) {
                    case "a\r":
                    case "a":
                        c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                        c.fillStyle = hexToRgb(this.color);
                        break;
                    case "b\r":
                    case "b":
                        c.fillRect(this.x, this.y, Math.PI * 6, Math.PI * 6);
                        c.strokeRect(this.x, this.y, Math.PI * 6, Math.PI * 6);
                        c.fillStyle = hexToRgb(this.color);
                        break;
                    case "c\r":
                    case "c":
                        c.moveTo(this.x, this.y-10);
                        c.lineTo(this.x -15, this.y+15);
                        c.lineTo(this.x +15, this.y+15);
                        c.fillStyle = hexToRgb(this.color);
                        break;

                    default:
                        c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                        c.fillStyle = hexToRgb(this.color);
                        break;
                }
                c.fill();
                c.stroke();
            }

            update = function () {
                this.draw();
            }
        }

        let btn = document.querySelector("#dataPointspawn");
         btn.addEventListener("click", function () {
            for (let i = 0; i < dataPoints.length; i++) {
                dataPoints[i].draw();
            }
        });



        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            var color = getNextColor();
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    let lines = content.trim().split('\n');

                    //seperate on comma and add to dataPoints
                    for (let i = 0; i < lines.length; i++) {
                        lines[i] = lines[i].split(',');
                        let dataPoint = new DataPoint(parseFloat(lines[i][0]), parseFloat(lines[i][1]), lines[i][2], 10, color);
                        dataPoints.push(dataPoint);
                        console.log(dataPoint.x, dataPoint.y, dataPoint.name);
                    }
                    preprocessing();
                };
                reader.readAsText(file);
            }
        });

        function scaleDataPoints(){
            var maxX = -Infinity;
            var minX = Infinity;
            var maxY = -Infinity;
            var minY = Infinity;

            for (let i = 0; i < dataPoints.length; i++) {


                if(maxX - minX == 0){
                    maxX = 1;
                }
                //console.log(dataPoints);

                if (dataPoints[i].x > maxX) {
                    maxX = dataPoints[i].x;
                }
                if (dataPoints[i].x < minX) {
                    minX = dataPoints[i].x;
                }
                if(dataPoints[i].y > maxY){
                    maxY = dataPoints[i].y;
                }
                if(dataPoints[i].y < minY){
                    minY = dataPoints[i].y;
                }

            }

            for (let i = 0; i < dataPoints.length; i++) {
                dataPoints[i].x = (dataPoints[i].x - minX) / (maxX - minX) * (displayWidth * 2 - 20);
                dataPoints[i].y = (dataPoints[i].y - minX) / (maxX - minX) * (displayHeight * 2 - 20);
            }  
            console.log(maxX, minX, maxY, minY);
        }

        function preprocessing() {
        
            scaleDataPoints();
            console.log(dataPoints)
            

            //return [x, y];

        } 
        
        // function dragBalls() {
        //     let mouseRadius = 1000;
        //     for (var i = 0; i < particleArray.length; i++) {
        //         var dx = Math.abs(mouse.x - particleArray[i].x);
        //         var dy = Math.abs(mouse.y - particleArray[i].y);
        //         var distance = Math.sqrt(dx * dx + dy * dy);
        //         if (distance <= particleArray[i].radius + mouseRadius) {
        //             //draw line to mouse
        //             c.beginPath();
        //             c.moveTo(particleArray[i].x, particleArray[i].y);
        //             c.lineTo(mouse.x, mouse.y);
        //             c.stroke();

        //             // add force to particle
        //             var dx = mouse.x - particleArray[i].x;
        //             var dy = mouse.y - particleArray[i].y;
        //             var distance = Math.sqrt(dx * dx + dy * dy);
        //             var minForce = 0.1;
        //             var maxForce = 100;
        //             // interpolate force
        //             var force = (distance - particleArray[i].radius) / (mouseRadius - particleArray[i].radius) * (maxForce - minForce) + minForce;

        //             var angle = Math.atan2(dy, dx);
        //             var fx = Math.cos(angle) * force;
        //             var fy = Math.sin(angle) * force;

        //             particleArray[i].ax += fx/particleArray[i].mass;
        //             particleArray[i].ay += fy/particleArray[i].mass;
        //         }
        //     }
        // }

        // var particleArray = [];

        // function checkSpawn(x, y) {
        //     for (let i = 0; i < particleArray.length; i++) {
        //         let particle = particleArray[i];
        //         if (particle.x + (particle.radius * 2) > x && particle.x - (particle.radius * 2) < x
        //             && particle.y + (particle.radius * 2) > y && particle.y - (particle.radius * 2) < y) {
        //             return false;
        //         }
        //     }
        //     return true;
        // }


        // function createParticle() {
        //     var radius = 50;
        //     var x = Math.random() * (tfCanvas.width - radius * 2) + radius;
        //     var y = Math.random() * (tfCanvas.height - radius * 2) + radius;
        //     while (!checkSpawn(x, y)) {
        //         x = Math.random() * (tfCanvas.width - radius * 2) + radius;
        //         y = Math.random() * (tfCanvas.height - radius * 2) + radius;
        //     }


        //     var color = getNextColor();
        //     particleArray.push(new Cricle(x, y, radius, color));
        // }

        function animate() {
            //c.clearRect(0, 0, innerWidth * 2, innerHeight * 2);
            
            for (var i = 0; i < dataPoints.length; i++) {
                dataPoints[i].draw();
            }
        }
        var color = getNextColor();
        // particleArray.push(new Cricle(625, 300, -0.5, 0.5, 0, 0, 50, color));
        // particleArray.push(new Cricle(300, 600, 2, -2, 0, 0, 50, color));

        // particleArray.push(new Cricle(500, 500, 1, 1, 0, 0, 50, color));
        // particleArray.push(new Cricle(800, 800, -2, -2, 0, 0, 50, color));

        //window.setInterval(animate, 1000 / FPS);
    });

    </script>

    <canvas id="simCanvas" width="window.width" height="window.height"></canvas>
    <!-- <button id="createParticleBtn" >Spawn a dozen balls</button> -->

</body>
</html>